<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Josiah Parry">

<title>Predicting to New Locations in Spatial ML</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="README_files/libs/clipboard/clipboard.min.js"></script>
<script src="README_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="README_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="README_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="README_files/libs/quarto-html/popper.min.js"></script>
<script src="README_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="README_files/libs/quarto-html/anchor.min.js"></script>
<link href="README_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="README_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="README_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="README_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="README_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="README.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Predicting to New Locations in Spatial ML</h1>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Author</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author">Josiah Parry <a href="mailto:jparry@esri.com" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> <a href="https://orcid.org/0000-0003-1689-0557" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a></p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Esri
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
  
    
  </div>
  


</header>


<section id="problem-statement" class="level2">
<h2 class="anchored" data-anchor-id="problem-statement">Problem Statement</h2>
<p>Predicting to new locations in spatially explicit machine learning models is ill-defined. These models use spatially lagged covariates, message passing in the case of graph neural networks (GNNs), or otherwise derived variables from the training data, which are defined only for locations embedded in the training spatial weights matrix (SWM). Prediction requires both identifying the neighborhood structure of new locations and accessing the covariate values used to construct spatially explicit features. Without this information, the required inputs do not exist.</p>
</section>
<section id="spatially-explicit-model-approaches" class="level2">
<h2 class="anchored" data-anchor-id="spatially-explicit-model-approaches">Spatially Explicit Model Approaches</h2>
<p>Models become spatially explicit through various mechanisms. The following approaches incorporate spatial relationships into machine learning models:</p>
<ul>
<li><strong>Spatial lags</strong>: Weighted averages of neighbor values in spatial regression models</li>
<li><strong>Message passing</strong>: Graph neural network mechanism equivalent to spatial lags on hidden dimensions</li>
<li><strong>Moran Eigenvector Maps (MEMs)</strong>: Spatial features derived from the spatial weights matrix</li>
<li><strong>Geographically Weighted Regression (GWR/MGWR)</strong>: Local regression coefficients estimated at each location</li>
<li><strong>Distance features</strong>: Covariates computed relative to external reference layers</li>
<li><strong>Coordinates and regimes</strong>: X/Y coordinates or spatial regimes as features (unproblematic for prediction)</li>
<li><strong>Location Embeddings</strong>: Models that take X/Y coordinates and create more “rich” variables from them</li>
<li><strong>Spatial indexing</strong>: H3, S2, or geohashes as categorical features (unproblematic for prediction)</li>
</ul>
<p>For simplicity, we focus on <strong>spatial lags</strong> as the canonical spatially explicit feature, though the challenges discussed apply broadly to approaches dependent on the spatial weights matrix or training data. At the end we discuss how these challenges extend to other approaches.</p>
</section>
<section id="spatially-explicit-model-prediction-scenarios" class="level2">
<h2 class="anchored" data-anchor-id="spatially-explicit-model-prediction-scenarios">Spatially Explicit Model Prediction Scenarios</h2>
<p>Consider a model trained on a study area with a spatial lag of variable <span class="math inline">\(X_1\)</span>. Four prediction scenarios emerge:</p>
<p><strong>1. Prediction at all original locations with updated covariates</strong>: Use the same adjacency matrix; calculate spatial lag from new <span class="math inline">\(X_1\)</span> values for all locations. Requires persisting or recreating the SWM and collecting new data for all locations.</p>
<p><strong>2. Prediction at a single original location</strong>: Use known adjacency; calculate lag from training data. Requires persisting the SWM and original <span class="math inline">\(X_1\)</span> values.</p>
<p><strong>3. Prediction at an entirely new study area</strong>: Create a new SWM for the new region; calculate spatial lag from new data. Raises questions about adjacency structure consistency (e.g., must k-NN be used if trained on k-NN?).</p>
<p><strong>4. Prediction at m new locations within the original study area</strong>: Most complex scenario—requires choosing how new locations relate to the training graph (see Approaches to Spatial Feature Construction below).</p>
<p><strong>Graph Neural Networks</strong>: GNNs face similar challenges. Transductive models cannot generalize to unseen nodes. Inductive models can generalize but still require graph structure for new nodes, necessitating insertion into or reconstruction of the adjacency matrix.</p>
</section>
<section id="approaches-to-spatial-feature-construction" class="level2">
<h2 class="anchored" data-anchor-id="approaches-to-spatial-feature-construction">Approaches to Spatial Feature Construction</h2>
<p>When confronting the train/test boundary, three coherent positions exist:</p>
<p><strong>A. Closed system (transductive)</strong>: Calculate spatial lag on the full dataset (train + test) before splitting. Semantically consistent but implies leakage and undefined prediction to new locations.</p>
<p><strong>B. Fully separate graphs</strong>: Lags computed independently within training and test sets. Semantically consistent but model is evaluated on a different graph structure than it was trained on.</p>
<p><strong>C. Hybrid approaches</strong>: Test lags incorporate training data. Two variants:</p>
<ul>
<li><strong>C1 (Individual lookup)</strong>: Each test point finds neighbors in the training set independently; test points do not see each other.</li>
<li><strong>C2 (Grow adjacency matrix)</strong>: Combine training and test points into a new adjacency matrix where test points can neighbor each other and training points.</li>
</ul>
<p>None of these approaches is obviously correct. Each involves trade-offs between semantic consistency and the ability to predict at new locations. The common practice (Position A) works for in-sample evaluation but leaves prediction to new locations undefined. Position C variants enable prediction but introduce semantic inconsistency—the model learns relationships among training neighbors but predicts using different neighbor definitions.</p>
</section>
<section id="challenges-for-prediction" class="level2">
<h2 class="anchored" data-anchor-id="challenges-for-prediction">Challenges for Prediction</h2>
<p>Three core challenges emerge across prediction scenarios:</p>
<p><strong>1. Modifying the Adjacency Matrix</strong>: New locations require insertion into or reconstruction of the SWM. For GNNs, new prediction points must be identified relative to the original adjacency matrix. The choice between insertion (preserving training structure) versus recomputation (rebuilding from scratch) involves trade-offs between consistency with training and spatial coherence of predictions.</p>
<p><strong>2. Feature Construction</strong>: Spatial lags for new locations require covariate values from neighbors. This raises the question: how do we determine which features are neighbors of the new prediction point? Those neighbors may be training observations, new observations, or both—corresponding to the positions outlined above.</p>
<p><strong>3. Storing the Adjacency Matrix and Training Features</strong>: Both adjacency modification and feature construction require access to the original SWM and covariate values. These must be persisted beyond training—not typically part of standard ML model serialization. For methods like GWR/MGWR, the entire training dataset must be stored alongside the model.</p>
<p>The literature largely overlooks these challenges. Papers focus on model training but do not account for predicting to <strong>new locations</strong>. This creates a gap between methodological innovation and operational deployment. Prediction at new locations is not a trivial extension of training—it requires explicit protocols for SWM persistence, adjacency decisions at prediction time, and covariate availability.</p>
</section>
<section id="examples-from-literature" class="level2">
<h2 class="anchored" data-anchor-id="examples-from-literature">Examples from Literature</h2>
<p><strong>Position A in practice <span class="citation" data-cites="Liu2022-pv">(<a href="#ref-Liu2022-pv" role="doc-biblioref">Liu, Kounadi, and Zurita-Milla 2022</a>)</span></strong>: Compute spatial lags on the full dataset before partitioning for cross-validation. This is common practice—works for in-sample evaluation but leaves prediction to new locations undefined.</p>
<p><strong>Position C1 in practice <span class="citation" data-cites="sarf2025">(<a href="#ref-sarf2025" role="doc-biblioref">Credit 2025</a>)</span></strong>: The <code>{sarf}</code> package’s <code>spatial_cv_rf()</code> function finds neighbors in the training set for each test observation independently. Test points do not see each other, even if spatially adjacent.</p>
<p><strong>Position C1 with explicit prediction <span class="citation" data-cites="Gao2025-mgwxgb">(<a href="#ref-Gao2025-mgwxgb" role="doc-biblioref">Gao, He, and Kwan 2025</a>)</span></strong>: M-GWXGB explicitly implements prediction to new locations by finding k-nearest training locations and averaging their local model predictions. This requires persisting all local models, training locations, and bandwidth—the model alone cannot predict.</p>
</section>
<section id="extension-to-other-spatially-explicit-approaches" class="level2">
<h2 class="anchored" data-anchor-id="extension-to-other-spatially-explicit-approaches">Extension to Other Spatially Explicit Approaches</h2>
<p>The three positions (A, B, C) and associated prediction challenges extend to other spatially explicit modeling techniques. Each approach presents different constraints on which positions are viable.</p>
<section id="potentially-problematic-approaches" class="level3">
<h3 class="anchored" data-anchor-id="potentially-problematic-approaches">Potentially Problematic Approaches</h3>
<p>These techniques avoid neighborhood dependencies but face out-of-distribution problems when predicting outside the training region:</p>
<ul>
<li>X/Y coordinates: Training on one region (e.g., North America) and predicting in another (e.g., Asia) encounters coordinate values never seen during training</li>
<li>Spatial indices (H3, S2, Geohash): Training on cells in one region and predicting in different cells creates unseen categorical values</li>
<li>Spatial regimes (state/county IDs): Training on one set of regimes and predicting on different regimes encounters unseen categorical values</li>
<li>Pre-trained location encoders: Global encoders like GeoCLIP <span class="citation" data-cites="cepeda2023geoclipclipinspiredalignmentlocations">(<a href="#ref-cepeda2023geoclipclipinspiredalignmentlocations" role="doc-biblioref">Cepeda, Nayak, and Shah 2023</a>)</span> work worldwide <span class="citation" data-cites="Zhang20012026">(<a href="#ref-Zhang20012026" role="doc-biblioref">Zhang et al. 2026</a>)</span>. Regional encoders trained on limited extents produce unreliable embeddings outside their training region</li>
<li>These approaches avoid spatial lag challenges (no SWM, no neighborhood definitions) but remain vulnerable to geographic distribution shift</li>
</ul>
</section>
<section id="distance-features" class="level3">
<h3 class="anchored" data-anchor-id="distance-features">Distance Features</h3>
<p>Distance features computed relative to external reference layers face analogous questions to spatial lags:</p>
<ul>
<li>Position A: Use only training distance features (requires storage and availability)</li>
<li>Position B: Calculate new distance features for test locations (requires reference layers; potential semantic inconsistency)</li>
<li>Position C2: Combine training and new distance features (raises questions about when augmentation is valid)</li>
<li>Like spatial lags, requires supplementary data beyond the model itself</li>
</ul>
</section>
<section id="moran-eigenvector-maps-mems" class="level3">
<h3 class="anchored" data-anchor-id="moran-eigenvector-maps-mems">Moran Eigenvector Maps (MEMs)</h3>
<p>MEMs are derived directly from the SWM, creating strong dependence on neighborhood structure:</p>
<ul>
<li>Position A: Store MEMs and query for predictions at original locations (straightforward)</li>
<li>Position B: Calculate MEMs on new data using same adjacency definition (inductive approach)</li>
<li>Position C: Cannot derive MEMs for new observations not in original SWM decomposition (eigenvector decomposition cannot be incrementally updated)</li>
<li>Particularly inflexible for prediction at new locations within the original study area</li>
</ul>
</section>
<section id="gwr-and-mgwr" class="level3">
<h3 class="anchored" data-anchor-id="gwr-and-mgwr">GWR and MGWR</h3>
<p>GWR and MGWR produce <span class="math inline">\(n\)</span> sets of local coefficients rather than a single global model. Prediction at new locations requires fitting new weighted regression using nearby training observations:</p>
<ul>
<li>Requires full training dataset (<span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>) at prediction time, not just serialized model</li>
<li>Bandwidth(s) from training can be reused, but coefficient estimation needs training data</li>
<li>Aligns with Position C1 (querying training set) but cannot escape model + data requirement</li>
<li>“Train once, predict anywhere” paradigm does not apply</li>
</ul>
</section>
<section id="graph-neural-networks" class="level3">
<h3 class="anchored" data-anchor-id="graph-neural-networks">Graph Neural Networks</h3>
<p>GNNs face similar but more rigid constraints:</p>
<ul>
<li>Transductive GNNs (e.g GCN): Fixed graph, cannot generalize to unseen nodes (inherently Position A)</li>
<li>Inductive GNNs (e.g.&nbsp;GraphSAGE): Can generalize to new structures (Position B) but still require graph structure at prediction time</li>
<li>Position C variants: Require reconstructing/augmenting adjacency matrix, then forward pass with expanded graph</li>
<li>Open question: Does inserting new nodes and running forward pass without retraining preserve semantic meaning or introduce Position C inconsistencies?</li>
</ul>

</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-cepeda2023geoclipclipinspiredalignmentlocations" class="csl-entry" role="listitem">
Cepeda, Vicente Vivanco, Gaurav Kumar Nayak, and Mubarak Shah. 2023. <span>“GeoCLIP: Clip-Inspired Alignment Between Locations and Images for Effective Worldwide Geo-Localization.”</span> <a href="https://arxiv.org/abs/2309.16020">https://arxiv.org/abs/2309.16020</a>.
</div>
<div id="ref-sarf2025" class="csl-entry" role="listitem">
Credit, Kevin. 2025. <span>“<span>SArf</span>: Spatial Autoregressive Random Forest.”</span> <a href="https://github.com/kcredit/SArf">https://github.com/kcredit/SArf</a>.
</div>
<div id="ref-Gao2025-mgwxgb" class="csl-entry" role="listitem">
Gao, Fan, Sylvia Y. He, and Mei-Po Kwan. 2025. <span>“Mixed Geographically Weighted <span>XGBoost</span> (<span>M-GWXGB</span>) Model: A New Spatially Explicit Machine Learning Model.”</span> <em>Annals of the American Association of Geographers</em>, December, 1–32. <a href="https://doi.org/10.1080/24694452.2025.2586039">https://doi.org/10.1080/24694452.2025.2586039</a>.
</div>
<div id="ref-Liu2022-pv" class="csl-entry" role="listitem">
Liu, Xiaojian, Ourania Kounadi, and Raul Zurita-Milla. 2022. <span>“Incorporating Spatial Autocorrelation in Machine Learning Models Using Spatial Lag and Eigenvector Spatial Filtering Features.”</span> <em>ISPRS Int. J. Geoinf.</em> 11 (4): 242.
</div>
<div id="ref-Zhang20012026" class="csl-entry" role="listitem">
Zhang, Jielu, Lan Mu, Gengchen Mai, Andrew Grundstein, Zhongliang Zhou, and Donglan Zhang. 2026. <span>“SpatialCausal: A Spatially-Aware Causal Inference Deep Learning Model for Out-of-Hospital Cardiac Arrest Survival Prediction.”</span> <em>International Journal of Geographical Information Science</em> 0 (0): 1–36. <a href="https://doi.org/10.1080/13658816.2025.2611981">https://doi.org/10.1080/13658816.2025.2611981</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>